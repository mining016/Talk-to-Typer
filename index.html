<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Kids Voice Typer</title>
    <style>
        @font-face {
            font-family: 'ChalkboardSE-Light';
            src: url('./fonts/ChalkboardSE-Light.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }

        :root {
            --primary-color: #4CAF50;
            --secondary-color: #2196F3;
            --accent-color: #FF9800;
            --bg-color: #E0F7FA;
            --chat-bg: #FFFFFF;
            --text-color: #333;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'ChalkboardSE-Light', 'Comic Sans MS', 'Chalkboard SE', sans-serif;
            background-color: var(--bg-color);
            height: 100dvh;
            /* Mobile viewport height fix */
            width: 100vw;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            /* Prevent body scroll */
        }

        /* Header */
        header {
            flex-shrink: 0;
            /* Don't shrink */
            background-color: var(--secondary-color);
            color: white;
            text-align: center;
            padding: 10px;
            font-size: 1.5rem;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            z-index: 10;
        }

        /* Chat Area */
        #chat-container {
            flex: 1;
            /* Take remaining space */
            padding: 20px;
            padding-bottom: 80px;
            /* Space for mic button overlap */
            overflow-y: auto;
            /* Scroll inside */
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
            gap: 15px;
            scroll-behavior: smooth;
            background-image: url('data:image/svg+xml,%3Csvg width="60" height="60" viewBox="0 0 60 60" xmlns="http://www.w3.org/2000/svg"%3E%3Cg fill="none" fill-rule="evenodd"%3E%3Cg fill="%239C92AC" fill-opacity="0.08"%3E%3Cpath d="M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z"/%3E%3C/g%3E%3C/g%3E%3C/svg%3E');
            width: 100%;
            box-sizing: border-box;
        }

        .message-bubble {
            background-color: #DCF8C6;
            /* WhatsApp sent message color */
            padding: 15px 20px;
            border-radius: 20px;
            border-bottom-right-radius: 5px;
            /* Pointy corner on right */
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
            max-width: 85%;
            font-size: 1.25rem;
            line-height: 1.5;
            color: var(--text-color);
            align-self: flex-end;
            /* Align to right */
            position: relative;
            animation: popIn 0.3s ease-out;
            margin-bottom: 5px;
        }

        @keyframes popIn {
            0% {
                transform: scale(0.8);
                opacity: 0;
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .interim-text {
            color: #999;
        }

        /* Bottom Control Bar */
        #control-bar {
            flex-shrink: 0;
            /* Fixed height */
            background-color: white;
            padding: 15px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
            z-index: 20;
            width: 100%;
            box-sizing: border-box;
            padding-bottom: env(safe-area-inset-bottom, 15px);
            /* Handle iPhone home bar */
        }

        /* Buttons */
        .btn {
            border: none;
            border-radius: 50px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            transition: transform 0.1s, background-color 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .btn:active {
            transform: scale(0.95);
        }

        #lang-toggle {
            background-color: var(--secondary-color);
            color: white;
            padding: 10px 20px;
            font-size: 1rem;
            width: 100px;
        }

        #clear-btn {
            background-color: #FF5252;
            color: white;
            padding: 10px 20px;
            font-size: 1rem;
            width: 100px;
        }

        /* Mic Button position tweaks */
        #mic-container {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            bottom: 30px;
            /* Adjust based on control bar height */
            z-index: 25;
            padding-bottom: env(safe-area-inset-bottom, 0px);
        }

        #mic-btn {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background-color: var(--primary-color);
            color: white;
            font-size: 2.5rem;
            box-shadow: 0 6px 15px rgba(76, 175, 80, 0.4);
            border: 4px solid white;
        }

        #mic-btn.listening {
            background-color: #F44336;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(244, 67, 54, 0.7);
            }

            70% {
                box-shadow: 0 0 0 20px rgba(244, 67, 54, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(244, 67, 54, 0);
            }
        }

        /* Language Flag Icon enhancement */
        .lang-icon {
            font-size: 1.2em;
            margin-right: 5px;
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            color: #888;
            margin-top: 50px;
            font-size: 1.2rem;
        }
    </style>
</head>

<body>

    <header>
        üéà Talk to Typer ü§ñ
    </header>

    <div id="chat-container">
        <div class="empty-state">
            Tap the Mic and start speaking! <br> üé§
        </div>
    </div>

    <div id="control-bar">
        <button id="lang-toggle" class="btn" onclick="toggleLanguage()">
            <span id="lang-display">üá¨üáß English</span>
        </button>

        <!-- Mic container moved inside control bar visually or just positioned relative to screen? 
             Absolute position relative to body might be safer for overlay. 
             Actually, keeping it in DOM order but absolute is fine.
        -->
        <div id="mic-container">
            <button id="mic-btn" class="btn" onclick="toggleListening()">
                üé§
            </button>
        </div>

        <button id="clear-btn" class="btn" onclick="clearChat()">
            üóëÔ∏è Clear
        </button>
    </div>

    <script>
        // DOM Elements
        const chatContainer = document.getElementById('chat-container');
        const micBtn = document.getElementById('mic-btn');
        const langDisplay = document.getElementById('lang-display');

        // State
        let isListening = false;
        let currentLang = 'en-US';
        let currentBubble = null;

        // Speech Recognition Setup
        const recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition || window.mozSpeechRecognition || window.msSpeechRecognition)();

        recognition.continuous = true;
        recognition.interimResults = true;
        recognition.lang = currentLang;

        recognition.onstart = () => {
            isListening = true;
            micBtn.classList.add('listening');
            micBtn.innerHTML = 'üõë';
            // Don't create bubble yet, wait for first sound result to avoid empty bubbles?
            // User requested "types as we speak", so immediate Feedback is good.
            // But if we restart session, we want a NEW bubble.
            // Let's create one now.
            createNewBubble();
            finalTranscript = ''; // Reset accumulator on start
        };

        recognition.onend = () => {
            isListening = false;
            micBtn.classList.remove('listening');
            micBtn.innerHTML = 'üé§';
            currentBubble = null; // Reset current bubble reference so next start creates a new one
        };

        recognition.onresult = (event) => {
            if (!currentBubble) {
                createNewBubble();
            }

            let interim = '';
            let newFinal = '';

            // Only process new results starting from resultIndex
            for (let i = event.resultIndex; i < event.results.length; ++i) {
                if (event.results[i].isFinal) {
                    newFinal += event.results[i][0].transcript;
                } else {
                    interim += event.results[i][0].transcript;
                }
            }

            // Append new final text to our session accumulator
            if (newFinal) {
                // Add space if needed
                if (finalTranscript && !finalTranscript.endsWith(' ') && !newFinal.startsWith(' ')) {
                    finalTranscript += ' ';
                }
                finalTranscript += newFinal;
            }

            // Update DOM with accumulator + interim
            // Use innerText/textContent style to be safe, but innerHTML for the span is needed.
            // We just set the content.
            currentBubble.innerHTML = finalTranscript + '<span class="interim-text" style="color: #999"> ' + interim + '</span>';

            scrollToBottom();
        };
        recognition.onerror = (event) => {
            console.error(event.error);
            // Optionally handle error visually
            if (event.error === 'no-speech') {
                // ignore
            }
        };

        // Functions
        function toggleListening() {
            if (isListening) {
                recognition.stop();
            } else {
                recognition.start();
            }
        }

        function toggleLanguage() {
            if (currentLang === 'en-US') {
                currentLang = 'hi-IN';
                langDisplay.innerText = 'üáÆüá≥ ‡§π‡§ø‡§Ç‡§¶‡•Ä';
            } else if (currentLang === 'hi-IN') {
                currentLang = 'gu-IN';
                langDisplay.innerText = 'üáÆüá≥ ‡™ó‡´Å‡™ú‡™∞‡™æ‡™§‡´Ä';
            } else {
                currentLang = 'en-US';
                langDisplay.innerText = 'üá¨üáß English';
            }

            recognition.lang = currentLang;

            // If listening, restart to apply language change
            if (isListening) {
                recognition.stop();
                // A small delay is sometimes needed for the engine to reset
                setTimeout(() => recognition.start(), 200);
            }
        }

        function createNewBubble() {
            // Remove empty state if present
            const emptyState = document.querySelector('.empty-state');
            if (emptyState) emptyState.remove();

            const bubble = document.createElement('div');
            bubble.classList.add('message-bubble');
            chatContainer.appendChild(bubble);
            currentBubble = bubble;
            scrollToBottom();
        }

        function clearChat() {
            chatContainer.innerHTML = '<div class="empty-state">Tap the Mic and start speaking! <br> üé§</div>';
            currentBubble = null;
            if (isListening) {
                // If we clear while listening, we probably want to start a fresh bubble immediately?
                // Or just stop.
                recognition.stop();
            }
        }

        function scrollToBottom() {
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

    </script>
</body>

</html>